# quicksort_c

### 概要

クイックソートのアルゴリズム  
C言語による実装

### 説明

1. クイックソートの計算量  
	1. 平均的な計算量  
		O(nlogn)

	1. ベストな場合の計算量  
		O(nlong)

	1. 最悪の場合の計算量  
		O(n^2)

1. アルゴリズム  
	1. 条件  
		配列の中央の値を決めなければならない。  
		配列の中央の値より前の要素たちは中央の値より小さく、  
		配列の中央の値より後ろの要素たちは中央の値より大きなものに  
		並び替えておく
	1. では、どのように条件を整えるか
		1. 用意するもの
			1. 配列の先頭を指すポインタpivot
			1. 配列の先頭の次の要素を指すポインタi
			1. 配列の最後の要素を指すポインタj
			1. 配列の最後の要素の値は処理系で最大の値(つまり番兵)とする
		1. 手順
			1. pivotとiの値、pivotとjの値を比較する
				1. j < pivot かつ pivot <= i   の関係ならjとiの値を入れ替える
					1. ポインタiが指す番地を一つ進める
					1. ポインタjが指す番地を一つ戻す
				1. j < pivot かつ pivot <= i  
				の関係でない場合、その条件を満たすまで  
				ポインタiを一つ進める、もしくはポインタjを  
				一つ戻す
			1. そのうちiとjは同じ番地を指し示し、次に交差する
			1. 交差した瞬間のjの値とpivotの値を入れ替える
			1. jは中央の値(かつ唯一のソート済要素)となり、条件が整う
			1. この一連の動作をクイックソートとする
	1. 実行  
		中央の値より前の要素たち、及び中央の値より後ろの要素たちに  
		再起的にクイックソートを実行する	

1. 最悪の場合とは  
	配列の分割結果に依存するということ。  
	配列がうまく半分ずつくらいに分かれてくれれば計算量はnlognに比例するが、  
	極端な分かれ方になった場合、計算量は増える。  
	最も最悪なケースは、整列済の配列に対してクイックソートを行う場合である

1. 選択ソートとクイックソートの違い  
	選択ソートは




